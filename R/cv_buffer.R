#' Use buffer around records to separate train and test folds (a.k.a. buffered/spatial leave-one-out)
#'
#' This function generates spatially separated train and test folds by considering buffers of
#' the specified distance (\code{size} parameter) around each observation point.
#' This approach is a form of \emph{leave-one-out} cross-validation. Each fold is generated by excluding
#' nearby observations around each testing point within the specified distance (ideally the range of
#' spatial autocorrelation, see \code{\link{cv_spatial_autocor}}). In this method, the testing set never
#' directly abuts a training sample (e.g. presence or absence; 0s and 1s). For more information see the details section.
#'
#' When working with presence-background (presence and pseudo-absence) species distribution
#' data (should be specified by \code{presence_background = TRUE} argument), only presence records are used
#' for specifying the folds (recommended). Consider a target presence point. The buffer is defined around this target point,
#' using the specified range (\code{size}). The testing fold comprises the target presence point and all background
#' points within the buffer (this is the default. If \code{add_background = FALSE} the background
#' points are ignored). Any non-target presence points inside the buffer are excluded.
#' All points (presence and background) outside of buffer are used for the training set.
#' The methods cycles through all the \emph{presence} data, so the number of folds is equal to
#' the number of presence points in the dataset.
#'
#' For presence-absence data (and all other types of data), folds are created based on all records, both
#' presences and absences. As above, a target observation (presence or absence) forms a test point, all
#' presence and absence points other than the target point within the buffer are ignored, and the training
#' set comprises all presences and absences outside the buffer. Apart from the folds, the number
#' of \emph{training-presence}, \emph{training-absence}, \emph{testing-presence} and \emph{testing-absence}
#' records is stored and returned in the \code{records} table. If \code{column = NULL} and \code{presence_background = FALSE},
#' the procedure is like presence-absence data. All other data types (continuous, count or multi-class responses) should be
#' done by \code{presence_background = FALSE}.
#'
#'
#' @inheritParams cv_spatial
#' @param column character; indicating the name of the column in which response variable (e.g. species data as a binary
#'  response i.e. 0s and 1s) is stored. This is required when \code{presence_background = TRUE}, otherwise optional.
#' @param presence_background logical; whether to treat data as presence-background species data. For all other data
#' types (continuous, count or multi-class responses), this option should be \code{FALSE}.
#' @param add_background logical; add background points to the test set when \code{presence_background = TRUE}. We do not
#' recommend according to Radosavljevic & Anderson (2014). Keep it \code{FALSE}, unless you mean to add
#' the background pints to testing points.
#' @param progress logical; whether to shows a progress bar.
#'
#' @seealso \code{\link{cv_spatial}}, \code{\link{cv_cluster}}, and \code{\link{cv_spatial_autocor}}
#'
#' @references Radosavljevic, A., & Anderson, R. P. (2014). Making better Maxent models of species
#' distributions: Complexity, overfitting and evaluation. Journal of Biogeography, 41, 629â€“643. https://doi.org/10.1111/jbi.12227
#'
#' @return An object of class S3. A list of objects including:
#'     \itemize{
#'     \item{folds_list - a list containing the folds. Each fold has two vectors with the training (first) and testing (second) indices}
#'     \item{k - number of the folds}
#'     \item{size - the distance band to separated trainig and testing folds)}
#'     \item{column - the name of the column if provided}
#'     \item{presence_background - whether this was treated as presence-background data}
#'     \item{records - a table with the number of points in each category of training and testing}
#'     }
#' @export
#'
#' @examples
#' \donttest{
#' library(blockCV)
#'
#' # import presence-absence species data
#' points <- read.csv(system.file("extdata/", "species.csv", package = "blockCV"))
#' # make an sf object from data.frame
#' pa_data <- sf::st_as_sf(points, coords = c("x", "y"), crs = 7845)
#'
#' # spatial clustering
#' bloo <- cv_buffer(x = pa_data,
#'                   column = "occ",
#'                   size = 250000, # size in metres (no matter the crs)
#'                   presence_background = FALSE)
#'
#' }
cv_buffer <- function(x,
                      column = NULL,
                      size,
                      presence_background = FALSE,
                      add_background = FALSE,
                      progress = TRUE){

  # check x is an sf object
  x <- .x_check(x)

  # x's CRS must be defined
  if(is.na(sf::st_crs(x))){
    stop("The coordinate reference system of x must be defined.")
  }
  # is column in x?
  if(!is.null(column)){
    if(!column %in% colnames(x)){
      warning(sprintf("There is no column named '%s' in 'x'.\n", column))
      column <- NULL
    }
  }

  if(is.null(column) && presence_background) stop("'column' must be provided for presence-background data.")

  # distance matrix by sf
  dmatrix <- sf::st_distance(x)
  distuni <- dmatrix[1,1] # take the unit to avoid using units package
  distuni[1] <- size
  fold_list <- list()

  if(!is.null(column)){
    if(presence_background){
      unqsp <- unique(x[, column, drop = TRUE])
      if(!is.numeric(unqsp) || any(unqsp < 0) || any(unqsp > 1)){
        stop("Presence-background option is only for species data with 0s (backgrounds/pseudo-absences) and 1s (presences).\n", "The data should be numeric.\n")
      }
      prI <- which(x[, column, drop = TRUE] == 1) # presence indices to loop through
      n <- length(prI)
      cl <- sort(unique(x[, column, drop = TRUE]))
      clen <- length(cl)
      train_test_table <- as.data.frame(matrix(0, nrow = n, ncol = clen * 2))
      names(train_test_table) <- c(paste("train", cl, sep = "_"), paste("test", cl, sep = "_"))
      if(progress) pb <- utils::txtProgressBar(min = 0, max = n, style = 3)
      j <- 0
      for(i in prI){ # loop through presences
        j <- j + 1
        train_set <- which(dmatrix[i, ] > distuni)
        if(add_background){
          test <- which(dmatrix[i, ] <= distuni)
          inside <- x[test, ]
          test_set <- test[which(inside[, column, drop = TRUE] == 0)]
          test_set[length(test_set) + 1] <- i
        } else{
          test_set <- i
        }
        fold_list[[j]] <- assign(paste0("fold", j), list(train_set, test_set))
        countrain <- table(x[train_set ,column, drop = TRUE])
        countest <- table(x[test_set ,column, drop = TRUE])
        train_test_table[j, which(cl %in% names(countrain))] <- countrain
        train_test_table[j, clen + which(cl %in% names(countest))] <- countest
        if(progress) utils::setTxtProgressBar(pb, i)
      }
    } else{
      n <- nrow(x)
      cl <- sort(unique(x[, column, drop = TRUE]))
      clen <- length(cl)
      train_test_table <- as.data.frame(matrix(0, nrow = n, ncol = clen * 2))
      names(train_test_table) <- c(paste("train", cl, sep = "_"), paste("test", cl, sep = "_"))
      if(progress) pb <- utils::txtProgressBar(min = 0, max = n, style = 3)
      for(i in seq_len(n)){
        train_set <- which(dmatrix[i, ] > distuni)
        test_set <- i
        fold_list[[i]] <- assign(paste0("fold", i), list(train_set, test_set))
        countrain <- table(x[train_set ,column, drop = TRUE])
        countest <- table(x[test_set ,column, drop = TRUE])
        train_test_table[i, which(cl %in% names(countrain))] <- countrain
        train_test_table[i, clen + which(cl %in% names(countest))] <- countest
        if(progress) utils::setTxtProgressBar(pb, i)
      }
    }
  } else{ # data with no column column
    n <- nrow(x)
    train_test_table <- base::data.frame(train = rep(0, n), test = 0)
    if(progress) pb <- utils::txtProgressBar(min = 0, max = n, style = 3)
    for(i in seq_len(n)){
      train_set <- which(dmatrix[i, ] > distuni)
      test_set <- i
      fold_list[[i]] <- assign(paste0("fold", i), list(train_set, test_set))
      train_test_table$train[i] <- length(train_set)
      train_test_table$test[i] <- length(test_set)
      if(progress) utils::setTxtProgressBar(pb, i)
    }
  }
  final_objs <- list(folds_list = fold_list,
                     k = n,
                     column = column,
                     size = size,
                     presence_background = presence_background,
                     records = train_test_table)

  class(final_objs) <- c("cv_buffer")
  return(final_objs)
}


#' @export
#' @method print cv_buffer
print.cv_buffer <- function(x, ...){
  print(class(x))
}

#' @export
#' @method summary cv_buffer
summary.cv_buffer <- function(object, ...){
  print("Number of recoreds in each category")
  print(object$records)
}
